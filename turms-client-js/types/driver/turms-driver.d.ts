import { im } from "../model/proto-bundle";
import { ParsedNotification } from "../model/parsed-notification";
import TurmsClient from "../turms-client";
import UserLocation from "../model/user-location";
import { SessionCloseInfo } from "../model/session-close-info";
import TurmsNotification = im.turms.proto.TurmsNotification;
import UserStatus = im.turms.proto.UserStatus;
import DeviceType = im.turms.proto.DeviceType;
export default class TurmsDriver {
    private _heartbeatInterval;
    private _turmsClient;
    private _websocket;
    private _heartbeatTimer?;
    private _onNotificationListeners;
    private _onClose?;
    private _url;
    private _httpUrl;
    private _connectionTimeout;
    private _requestTimeout;
    private _minRequestsInterval;
    private _requestsMap;
    private _lastRequestDate;
    private _queryReasonWhenLoginFailed;
    private _queryReasonWhenDisconnected;
    private _isClosedByClient;
    private _heartbeatCallbacks;
    private _requestId;
    private _sessionId?;
    constructor(turmsClient: TurmsClient, url?: string, connectionTimeout?: number, requestTimeout?: number, minRequestsInterval?: number, httpUrl?: string, queryReasonWhenLoginFailed?: boolean, queryReasonWhenDisconnected?: boolean);
    set onClose(value: (closeInfo: SessionCloseInfo) => void);
    get onNotificationListeners(): ((notification: ParsedNotification) => void)[];
    sendHeartbeat(): Promise<void>;
    connected(): boolean;
    disconnect(): Promise<void>;
    private _connect;
    connect(userId: string, password: string, deviceType?: DeviceType, userOnlineStatus?: UserStatus, location?: UserLocation): Promise<void>;
    resetHeartBeatTimer(): void;
    send(message: im.turms.proto.ITurmsRequest): Promise<TurmsNotification>;
    private static _fillLoginInfo;
    private static _clearLoginInfo;
    private _generateRandomId;
    private _onWebsocketOpen;
    private _onWebsocketClose;
    reconnect(host?: string): Promise<void>;
    _getIfBusinessCloseStatus(closeCode: number): number;
}
